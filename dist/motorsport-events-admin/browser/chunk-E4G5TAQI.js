import{c as pe,d as H}from"./chunk-B2MOJN65.js";var n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1};var B="app";var cs=pe({});var _,se,D,it,lt=0,ze=!1,M=!1,Y=!1,S=!1,ge=null,V=0,W=!1,me={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting},$s=e=>{let t=new URL(e,p.$resourcesUrl$);return t.origin!==z.location.origin?t.href:t.pathname};var L=(e,t="")=>{if(n.profile&&performance.mark){let s=`st:${e}:${t}:${lt++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},rt=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{};var at="r",ct="o",dt="s",$t="t",ne="s-id",ye="sty-id",ve="c-id";var ft="slot-fb{display:contents}slot-fb[hidden]{display:none}",Se="http://www.w3.org/1999/xlink",ut=["formAssociatedCallback","formResetCallback","formDisabledCallback","formStateRestoreCallback"],be={},ht="http://www.w3.org/2000/svg",pt="http://www.w3.org/1999/xhtml",gt=e=>e!=null,$e=e=>(e=typeof e,e==="object"||e==="function");function mt(e){var t,s,o;return(o=(s=(t=e.head)===null||t===void 0?void 0:t.querySelector('meta[name="csp-nonce"]'))===null||s===void 0?void 0:s.getAttribute("content"))!==null&&o!==void 0?o:void 0}var je=(e,t,...s)=>{let o=null,i=null,l=null,r=!1,c=!1,a=[],d=f=>{for(let h=0;h<f.length;h++)o=f[h],Array.isArray(o)?d(o):o!=null&&typeof o!="boolean"&&((r=typeof e!="function"&&!$e(o))?o=String(o):n.isDev&&typeof e!="function"&&o.$flags$===void 0&&Q(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),r&&c?a[a.length-1].$text$+=o:a.push(r?R(null,o):o),c=r)};if(d(s),t&&(n.isDev&&e==="input"&&bt(t),n.vdomKey&&t.key&&(i=t.key),n.slotRelocation&&t.name&&(l=t.name),n.vdomClass)){let f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(h=>f[h]).join(" "))}if(n.isDev&&a.some(oe)&&Q(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,a,vt);let $=R(e,null);return $.$attrs$=t,a.length>0&&($.$children$=a),n.vdomKey&&($.$key$=i),n.slotRelocation&&($.$name$=l),$},R=(e,t)=>{let s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},yt={},oe=e=>e&&e.$tag$===yt,vt={forEach:(e,t)=>e.map(xe).forEach(t),map:(e,t)=>e.map(xe).map(t).map(St)},xe=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),St=e=>{if(typeof e.vtag=="function"){let s=Object.assign({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),je(e.vtag,s,...e.vchildren||[])}let t=R(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},bt=e=>{let t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;let o=t.indexOf("type"),i=t.indexOf("min"),l=t.indexOf("max"),r=t.indexOf("step");(s<o||s<i||s<l||s<r)&&P('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},xt=(e,t,s,o)=>{let i=L("hydrateClient",t),l=e.shadowRoot,r=[],c=[],a=n.shadowDom&&l?[]:null,d=o.$vnode$=R(t,null);p.$orgLocNodes$||le(m.body,p.$orgLocNodes$=new Map),e[ne]=s,e.removeAttribute(ne),ie(d,r,c,a,e,e,s),r.map($=>{let f=$.$hostId$+"."+$.$nodeId$,h=p.$orgLocNodes$.get(f),u=$.$elm$;h&&w&&h["s-en"]===""&&h.parentNode.insertBefore(u,h.nextSibling),l||(u["s-hn"]=t,h&&(u["s-ol"]=h,u["s-ol"]["s-nr"]=u)),p.$orgLocNodes$.delete(f)}),n.shadowDom&&l&&a.map($=>{$&&l.appendChild($)}),i()},ie=(e,t,s,o,i,l,r)=>{let c,a,d,$;if(l.nodeType===1){for(c=l.getAttribute(ve),c&&(a=c.split("."),(a[0]===r||a[0]==="0")&&(d={$flags$:0,$hostId$:a[0],$nodeId$:a[1],$depth$:a[2],$index$:a[3],$tag$:l.tagName.toLowerCase(),$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push(d),l.removeAttribute(ve),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,e=d,o&&d.$depth$==="0"&&(o[d.$index$]=d.$elm$))),$=l.childNodes.length-1;$>=0;$--)ie(e,t,s,o,i,l.childNodes[$],r);if(l.shadowRoot)for($=l.shadowRoot.childNodes.length-1;$>=0;$--)ie(e,t,s,o,i,l.shadowRoot.childNodes[$],r)}else if(l.nodeType===8)a=l.nodeValue.split("."),(a[1]===r||a[1]==="0")&&(c=a[0],d={$flags$:0,$hostId$:a[1],$nodeId$:a[2],$depth$:a[3],$index$:a[4],$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},c===$t?(d.$elm$=l.nextSibling,d.$elm$&&d.$elm$.nodeType===3&&(d.$text$=d.$elm$.textContent,t.push(d),l.remove(),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,o&&d.$depth$==="0"&&(o[d.$index$]=d.$elm$))):d.$hostId$===r&&(c===dt?(d.$tag$="slot",a[5]?l["s-sn"]=d.$name$=a[5]:l["s-sn"]="",l["s-sr"]=!0,n.shadowDom&&o&&(d.$elm$=m.createElement(d.$tag$),d.$name$&&d.$elm$.setAttribute("name",d.$name$),l.parentNode.insertBefore(d.$elm$,l),l.remove(),d.$depth$==="0"&&(o[d.$index$]=d.$elm$)),s.push(d),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d):c===at&&(n.shadowDom&&o?l.remove():n.slotRelocation&&(i["s-cr"]=l,l["s-cn"]=!0))));else if(e&&e.$tag$==="style"){let f=R(null,l.textContent);f.$elm$=l,f.$index$="0",e.$children$=[f]}},le=(e,t)=>{if(e.nodeType===1){let s=0;for(;s<e.childNodes.length;s++)le(e.childNodes[s],t);if(e.shadowRoot)for(s=0;s<e.shadowRoot.childNodes.length;s++)le(e.shadowRoot.childNodes[s],t)}else if(e.nodeType===8){let s=e.nodeValue.split(".");s[0]===ct&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},Tt=e=>nt.map(t=>t(e)).find(t=>!!t),fs=e=>nt.push(e),us=e=>b(e).$modeName$,Lt=(e,t)=>e!=null&&!$e(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,Ct=e=>n.lazyLoad?b(e).$hostElement$:e,hs=(e,t,s)=>{let o=Ct(e);return{emit:i=>(n.isDev&&!o.isConnected&&P(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),fe(o,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:i}))}},fe=(e,t,s)=>{let o=p.ce(t,s);return e.dispatchEvent(o),o},Te=new WeakMap,Nt=(e,t,s)=>{let o=X.get(e);os&&s?(o=o||new CSSStyleSheet,typeof o=="string"?o=t:o.replaceSync(t)):o=t,X.set(e,o)},re=(e,t,s)=>{var o;let i=Pe(t,s),l=X.get(i);if(!n.attachStyles)return i;if(e=e.nodeType===11?e:m,l)if(typeof l=="string"){e=e.head||e;let r=Te.get(e),c;if(r||Te.set(e,r=new Set),!r.has(i)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${ye}="${i}"]`)))c.innerHTML=l;else{c=m.createElement("style"),c.innerHTML=l;let a=(o=p.$nonce$)!==null&&o!==void 0?o:mt(m);a!=null&&c.setAttribute("nonce",a),(n.hydrateServerSide||n.hotModuleReplacement)&&c.setAttribute(ye,i),e.insertBefore(c,e.querySelector("link"))}t.$flags$&4&&(c.innerHTML+=ft),r&&r.add(i)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(l)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return i},Dt=e=>{let t=e.$cmpMeta$,s=e.$hostElement$,o=t.$flags$,i=L("attachStyles",t.$tagName$),l=re(n.shadowDom&&w&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);(n.shadowDom||n.scoped)&&n.cssAnnotations&&o&10&&(s["s-sc"]=l,s.classList.add(l+"-h"),n.scoped&&o&2&&s.classList.add(l+"-s")),i()},Pe=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$);var Le=(e,t,s,o,i,l)=>{if(s!==o){let r=Ee(e,t),c=t.toLowerCase();if(n.vdomClass&&t==="class"){let a=e.classList,d=Ce(s),$=Ce(o);a.remove(...d.filter(f=>f&&!$.includes(f))),a.add(...$.filter(f=>f&&!d.includes(f)))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(let a in s)(!o||o[a]==null)&&(!n.hydrateServerSide&&a.includes("-")?e.style.removeProperty(a):e.style[a]="");for(let a in o)(!s||o[a]!==s[a])&&(!n.hydrateServerSide&&a.includes("-")?e.style.setProperty(a,o[a]):e.style[a]=o[a])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")o&&o(e);else if(n.vdomListener&&(n.lazyLoad?!r:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):Ee(z,c)?t=c.slice(2):t=c[2]+t.slice(3),s||o){let a=t.endsWith(He);t=t.replace(At,""),s&&p.rel(e,t,s,a),o&&p.ael(e,t,o,a)}}else if(n.vdomPropOrAttr){let a=$e(o);if((r||a&&o!==null)&&!i)try{if(e.tagName.includes("-"))e[t]=o;else{let $=o??"";t==="list"?r=!1:(s==null||e[t]!=$)&&(e[t]=$)}}catch{}let d=!1;n.vdomXlink&&c!==(c=c.replace(/^xlink\:?/,""))&&(t=c,d=!0),o==null||o===!1?(o!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&d?e.removeAttributeNS(Se,t):e.removeAttribute(t)):(!r||l&4||i)&&!a&&(o=o===!0?"":o,n.vdomXlink&&d?e.setAttributeNS(Se,t,o):e.setAttribute(t,o))}}}},kt=/\s/,Ce=e=>e?e.split(kt):[],He="Capture",At=new RegExp(He+"$"),Be=(e,t,s,o)=>{let i=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||be,r=t.$attrs$||be;if(n.updatable)for(o in l)o in r||Le(i,o,l[o],void 0,s,t.$flags$);for(o in r)Le(i,o,l[o],r[o],s,t.$flags$)},q=(e,t,s,o)=>{let i=t.$children$[s],l=0,r,c,a;if(n.slotRelocation&&!ze&&(Y=!0,i.$tag$==="slot"&&(_&&o.classList.add(_+"-s"),i.$flags$|=i.$children$?2:1)),n.isDev&&i.$elm$&&Q(`The JSX ${i.$text$!==null?`"${i.$text$}" text`:`"${i.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&i.$text$!==null)r=i.$elm$=m.createTextNode(i.$text$);else if(n.slotRelocation&&i.$flags$&1)r=i.$elm$=n.isDebug||n.hydrateServerSide?Et(i):m.createTextNode("");else{if(n.svg&&!S&&(S=i.$tag$==="svg"),r=i.$elm$=n.svg?m.createElementNS(S?ht:pt,n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$):m.createElement(n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$),n.svg&&S&&i.$tag$==="foreignObject"&&(S=!1),n.vdomAttribute&&Be(null,i,S),(n.shadowDom||n.scoped)&&gt(_)&&r["s-si"]!==_&&r.classList.add(r["s-si"]=_),i.$children$)for(l=0;l<i.$children$.length;++l)c=q(e,i,l,r),c&&r.appendChild(c);n.svg&&(i.$tag$==="svg"?S=!1:r.tagName==="foreignObject"&&(S=!0))}return r["s-hn"]=D,n.slotRelocation&&i.$flags$&3&&(r["s-sr"]=!0,r["s-cr"]=se,r["s-sn"]=i.$name$||"",a=e&&e.$children$&&e.$children$[s],a&&a.$tag$===i.$tag$&&e.$elm$&&(n.experimentalSlotFixes?wt(e.$elm$):j(e.$elm$,!1))),r},wt=e=>{p.$flags$|=1;let t=e.closest(D.toLowerCase());if(t!=null)for(let s of Array.from(e.childNodes))s["s-sh"]!=null&&(t.insertBefore(s,null),s["s-sh"]=void 0,Y=!0);p.$flags$&=-2},j=(e,t)=>{p.$flags$|=1;let s=e.childNodes;for(let o=s.length-1;o>=0;o--){let i=s[o];i["s-hn"]!==D&&i["s-ol"]&&(Me(i).insertBefore(i,ue(i)),i["s-ol"].remove(),i["s-ol"]=void 0,i["s-sh"]=void 0,Y=!0),t&&j(i,t)}p.$flags$&=-2},Fe=(e,t,s,o,i,l)=>{let r=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,c;for(n.shadowDom&&r.shadowRoot&&r.tagName===D&&(r=r.shadowRoot);i<=l;++i)o[i]&&(c=q(null,s,i,e),c&&(o[i].$elm$=c,r.insertBefore(c,n.slotRelocation?ue(t):t)))},Ue=(e,t,s)=>{for(let o=t;o<=s;++o){let i=e[o];if(i){let l=i.$elm$;qe(i),l&&(n.slotRelocation&&(M=!0,l["s-ol"]?l["s-ol"].remove():j(l,!0)),l.remove())}}},_t=(e,t,s,o,i=!1)=>{let l=0,r=0,c=0,a=0,d=t.length-1,$=t[0],f=t[d],h=o.length-1,u=o[0],g=o[h],v,y;for(;l<=d&&r<=h;)if($==null)$=t[++l];else if(f==null)f=t[--d];else if(u==null)u=o[++r];else if(g==null)g=o[--h];else if(F($,u,i))E($,u,i),$=t[++l],u=o[++r];else if(F(f,g,i))E(f,g,i),f=t[--d],g=o[--h];else if(F($,g,i))n.slotRelocation&&($.$tag$==="slot"||g.$tag$==="slot")&&j($.$elm$.parentNode,!1),E($,g,i),e.insertBefore($.$elm$,f.$elm$.nextSibling),$=t[++l],g=o[--h];else if(F(f,u,i))n.slotRelocation&&($.$tag$==="slot"||g.$tag$==="slot")&&j(f.$elm$.parentNode,!1),E(f,u,i),e.insertBefore(f.$elm$,$.$elm$),f=t[--d],u=o[++r];else{if(c=-1,n.vdomKey){for(a=l;a<=d;++a)if(t[a]&&t[a].$key$!==null&&t[a].$key$===u.$key$){c=a;break}}n.vdomKey&&c>=0?(y=t[c],y.$tag$!==u.$tag$?v=q(t&&t[r],s,c,e):(E(y,u,i),t[c]=void 0,v=y.$elm$),u=o[++r]):(v=q(t&&t[r],s,r,e),u=o[++r]),v&&(n.slotRelocation?Me($.$elm$).insertBefore(v,ue($.$elm$)):$.$elm$.parentNode.insertBefore(v,$.$elm$))}l>d?Fe(e,o[h+1]==null?null:o[h+1].$elm$,s,o,r,h):n.updatable&&r>h&&Ue(t,l,d)},F=(e,t,s=!1)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?e.$name$===t.$name$:n.vdomKey&&!s?e.$key$===t.$key$:!0:!1,ue=e=>e&&e["s-ol"]||e,Me=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,E=(e,t,s=!1)=>{let o=t.$elm$=e.$elm$,i=e.$children$,l=t.$children$,r=t.$tag$,c=t.$text$,a;!n.vdomText||c===null?(n.svg&&(S=r==="svg"?!0:r==="foreignObject"?!1:S),(n.vdomAttribute||n.reflect)&&(n.slot&&r==="slot"||Be(e,t,S)),n.updatable&&i!==null&&l!==null?_t(o,i,t,l,s):l!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(o.textContent=""),Fe(o,null,t,l,0,l.length-1)):n.updatable&&i!==null&&Ue(i,0,i.length-1),n.svg&&S&&r==="svg"&&(S=!1)):n.vdomText&&n.slotRelocation&&(a=o["s-cr"])?a.parentNode.textContent=c:n.vdomText&&e.$text$!==c&&(o.data=c)},G=e=>{let t=e.childNodes;for(let s of t)if(s.nodeType===1){if(s["s-sr"]){let o=s["s-sn"];s.hidden=!1;for(let i of t)if(i!==s){if(i["s-hn"]!==s["s-hn"]||o!==""){if(i.nodeType===1&&(o===i.getAttribute("slot")||o===i["s-sn"])){s.hidden=!0;break}}else if(i.nodeType===1||i.nodeType===3&&i.textContent.trim()!==""){s.hidden=!0;break}}}G(s)}},T=[],We=e=>{let t,s,o;for(let i of e.childNodes){if(i["s-sr"]&&(t=i["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;let l=i["s-sn"];for(o=s.length-1;o>=0;o--)if(t=s[o],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==i["s-hn"]&&(!n.experimentalSlotFixes||!t["s-sh"]||t["s-sh"]!==i["s-hn"]))if(Ne(t,l)){let r=T.find(c=>c.$nodeToRelocate$===t);M=!0,t["s-sn"]=t["s-sn"]||l,r?(r.$nodeToRelocate$["s-sh"]=i["s-hn"],r.$slotRefNode$=i):(t["s-sh"]=i["s-hn"],T.push({$slotRefNode$:i,$nodeToRelocate$:t})),t["s-sr"]&&T.map(c=>{Ne(c.$nodeToRelocate$,t["s-sn"])&&(r=T.find(a=>a.$nodeToRelocate$===t),r&&!c.$slotRefNode$&&(c.$slotRefNode$=r.$slotRefNode$))})}else T.some(r=>r.$nodeToRelocate$===t)||T.push({$nodeToRelocate$:t})}i.nodeType===1&&We(i)}},Ne=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",qe=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(qe))},De=(e,t,s=!1)=>{var o,i,l,r,c;let a=e.$hostElement$,d=e.$cmpMeta$,$=e.$vnode$||R(null,null),f=oe(t)?t:je(null,null,t);if(D=a.tagName,n.isDev&&Array.isArray(t)&&t.some(oe))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${D.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&d.$attrsToReflect$&&(f.$attrs$=f.$attrs$||{},d.$attrsToReflect$.map(([h,u])=>f.$attrs$[u]=a[h])),s&&f.$attrs$)for(let h of Object.keys(f.$attrs$))a.hasAttribute(h)&&!["key","ref","style","class"].includes(h)&&(f.$attrs$[h]=a[h]);if(f.$tag$=null,f.$flags$|=4,e.$vnode$=f,f.$elm$=$.$elm$=n.shadowDom&&a.shadowRoot||a,(n.scoped||n.shadowDom)&&(_=a["s-sc"]),n.slotRelocation&&(se=a["s-cr"],ze=w&&(d.$flags$&1)!==0,M=!1),E($,f,s),n.slotRelocation){if(p.$flags$|=1,Y){We(f.$elm$);for(let h of T){let u=h.$nodeToRelocate$;if(!u["s-ol"]){let g=n.isDebug||n.hydrateServerSide?It(u):m.createTextNode("");g["s-nr"]=u,u.parentNode.insertBefore(u["s-ol"]=g,u)}}for(let h of T){let u=h.$nodeToRelocate$,g=h.$slotRefNode$;if(g){let v=g.parentNode,y=g.nextSibling;if(!n.experimentalSlotFixes||y&&y.nodeType===1){let k=(o=u["s-ol"])===null||o===void 0?void 0:o.previousSibling;for(;k;){let N=(i=k["s-nr"])!==null&&i!==void 0?i:null;if(N&&N["s-sn"]===u["s-sn"]&&v===N.parentNode&&(N=N.nextSibling,!N||!N["s-nr"])){y=N;break}k=k.previousSibling}}(!y&&v!==u.parentNode||u.nextSibling!==y)&&u!==y&&(!n.experimentalSlotFixes&&!u["s-hn"]&&u["s-ol"]&&(u["s-hn"]=u["s-ol"].parentNode.nodeName),v.insertBefore(u,y),u.nodeType===1&&(u.hidden=(l=u["s-ih"])!==null&&l!==void 0?l:!1))}else u.nodeType===1&&(s&&(u["s-ih"]=(r=u.hidden)!==null&&r!==void 0?r:!1),u.hidden=!0)}}M&&G(f.$elm$),p.$flags$&=-2,T.length=0}if(n.experimentalScopedSlotChanges&&d.$flags$&2)for(let h of f.$elm$.childNodes)h["s-hn"]!==D&&!h["s-sh"]&&(s&&h["s-ih"]==null&&(h["s-ih"]=(c=h.hidden)!==null&&c!==void 0?c:!1),h.hidden=!0);se=void 0},Et=e=>m.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${D.toLowerCase()})`),It=e=>m.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),Qe=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},J=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}Qe(e,e.$ancestorComponent$);let s=()=>Rt(e,t);return n.taskQueue?is(s):s()},Rt=(e,t)=>{let s=e.$hostElement$,o=L("scheduleUpdate",e.$cmpMeta$.$tagName$),i=n.lazyLoad?e.$lazyInstance$:s,l;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([r,c])=>x(i,r,c)),e.$queuedListeners$=void 0)),I(s,"componentWillLoad"),n.cmpWillLoad&&(l=x(i,"componentWillLoad"))):(I(s,"componentWillUpdate"),n.cmpWillUpdate&&(l=x(i,"componentWillUpdate"))),I(s,"componentWillRender"),n.cmpWillRender&&(l=ke(l,()=>x(i,"componentWillRender"))),o(),ke(l,()=>zt(e,i,t))},ke=(e,t)=>Ot(e)?e.then(t):t(),Ot=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",zt=(e,t,s)=>H(void 0,null,function*(){var o;let i=e.$hostElement$,l=L("update",e.$cmpMeta$.$tagName$),r=i["s-rc"];n.style&&s&&Dt(e);let c=L("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?yield Ae(e,t,i,s):Ae(e,t,i,s),n.isDev&&(e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025),n.hydrateServerSide)try{Ke(i),s&&(e.$cmpMeta$.$flags$&1?i["s-en"]="":e.$cmpMeta$.$flags$&2&&(i["s-en"]="c"))}catch(a){C(a,i)}if(n.asyncLoading&&r&&(r.map(a=>a()),i["s-rc"]=void 0),c(),l(),n.asyncLoading){let a=(o=i["s-p"])!==null&&o!==void 0?o:[],d=()=>we(e);a.length===0?d():(Promise.all(a).then(d),e.$flags$|=4,a.length=0)}else we(e)}),Ae=(e,t,s,o)=>{let i=!!n.allRenderFn,l=!!n.lazyLoad,r=!!n.taskQueue,c=!!n.updatable;try{if(ge=t,t=(i||t.render)&&t.render(),c&&r&&(e.$flags$&=-17),(c||l)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(a=>De(e,a,o));De(e,t,o)}else{let a=s.shadowRoot;e.$cmpMeta$.$flags$&1?a.textContent=t:s.textContent=t}}catch(a){C(a,e.$hostElement$)}return ge=null,null};var we=e=>{let t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,o=L("postUpdate",t),i=n.lazyLoad?e.$lazyInstance$:s,l=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),x(i,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),I(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),x(i,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),I(s,"componentDidUpdate"),o()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&Xe(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),x(i,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),I(s,"componentDidLoad"),o(),n.asyncLoading&&(e.$onReadyResolve$(s),l||Pt(t))),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&Z(()=>J(e,!1)),e.$flags$&=-517)},jt=e=>{if(n.updatable&&(me.isBrowser||me.isTesting)){let t=b(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&J(t,!1),s}return!1},Pt=e=>{n.cssAnnotations&&Xe(m.documentElement),n.asyncQueue&&(p.$flags$|=2),Z(()=>fe(z,"appload",{detail:{namespace:B}})),n.profile&&performance.measure&&performance.measure(`[Stencil] ${B} initial load (by ${e})`,"st:app:start")},x=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(o){C(o)}},I=(e,t)=>{n.lifecycleDOMEvents&&fe(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:B}})},Xe=e=>n.hydratedClass?e.classList.add("hydrated"):n.hydratedAttribute?e.setAttribute("hydrated",""):void 0,Ke=e=>{let t=e.children;if(t!=null)for(let s=0,o=t.length;s<o;s++){let i=t[s];typeof i.connectedCallback=="function"&&i.connectedCallback(),Ke(i)}},Ht=(e,t)=>b(e).$instanceValues$.get(t),Bt=(e,t,s,o)=>{let i=b(e),l=n.lazyLoad?i.$hostElement$:e,r=i.$instanceValues$.get(t),c=i.$flags$,a=n.lazyLoad?i.$lazyInstance$:l;s=Lt(s,o.$members$[t][0]);let d=Number.isNaN(r)&&Number.isNaN(s),$=s!==r&&!d;if((!n.lazyLoad||!(c&8)||r===void 0)&&$&&(i.$instanceValues$.set(t,s),n.isDev&&(i.$flags$&1024?P(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,l,`
New value`,s,`
Old value`,r):i.$flags$&2048&&P(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,l,`
New value`,s,`
Old value`,r)),!n.lazyLoad||a)){if(n.watchCallback&&o.$watchers$&&c&128){let f=o.$watchers$[t];f&&f.map(h=>{try{a[h](s,r,t)}catch(u){C(u,l)}})}if(n.updatable&&(c&18)===2){if(n.cmpShouldUpdate&&a.componentShouldUpdate&&a.componentShouldUpdate(s,r,t)===!1)return;J(i,!1)}}},Ye=(e,t,s)=>{var o;let i=e.prototype;if(n.formAssociated&&t.$flags$&64&&s&1&&ut.forEach(l=>Object.defineProperty(i,l,{value(...r){let c=b(this),a=n.lazyLoad?c.$hostElement$:this,d=n.lazyLoad?c.$lazyInstance$:a;if(!d)c.$onReadyPromise$.then($=>{let f=$[l];typeof f=="function"&&f.call($,...r)});else{let $=d[l];typeof $=="function"&&$.call(d,...r)}}})),n.member&&t.$members$){n.watchCallback&&e.watchers&&(t.$watchers$=e.watchers);let l=Object.entries(t.$members$);if(l.map(([r,[c]])=>{(n.prop||n.state)&&(c&31||(!n.lazyLoad||s&2)&&c&32)?Object.defineProperty(i,r,{get(){return Ht(this,r)},set(a){if(n.isDev){let d=b(this);!(s&1)&&(d&&d.$flags$&8)===0&&c&31&&!(c&1024)&&P(`@Prop() "${r}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}Bt(this,r,a,t)},configurable:!0,enumerable:!0}):n.lazyLoad&&n.method&&s&1&&c&64&&Object.defineProperty(i,r,{value(...a){var d;let $=b(this);return(d=$?.$onInstancePromise$)===null||d===void 0?void 0:d.then(()=>{var f;return(f=$.$lazyInstance$)===null||f===void 0?void 0:f[r](...a)})}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){let r=new Map;i.attributeChangedCallback=function(c,a,d){p.jmp(()=>{var $;let f=r.get(c);if(this.hasOwnProperty(f))d=this[f],delete this[f];else{if(i.hasOwnProperty(f)&&typeof this[f]=="number"&&this[f]==d)return;if(f==null){let h=b(this),u=h?.$flags$;if(u&&!(u&8)&&u&128&&d!==a){let g=n.lazyLoad?h.$hostElement$:this,v=n.lazyLoad?h.$lazyInstance$:g,y=($=t.$watchers$)===null||$===void 0?void 0:$[c];y?.forEach(k=>{v[k]!=null&&v[k].call(v,d,a,c)})}return}}this[f]=d===null&&typeof this[f]=="boolean"?!1:d})},e.observedAttributes=Array.from(new Set([...Object.keys((o=t.$watchers$)!==null&&o!==void 0?o:{}),...l.filter(([c,a])=>a[0]&15).map(([c,a])=>{var d;let $=a[1]||c;return r.set($,c),n.reflect&&a[0]&512&&((d=t.$attrsToReflect$)===null||d===void 0||d.push([c,$])),$})]))}}return e},_e=(e,t,s,o)=>H(void 0,null,function*(){let i;if(!(t.$flags$&32)){if(t.$flags$|=32,n.lazyLoad||n.hydrateClientSide){if(i=ts(s,t,o),i.then){let a=rt(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);i=yield i,a()}if((n.isDev||n.isDebug)&&!i)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!i.isProxied&&(n.watchCallback&&(s.$watchers$=i.watchers),Ye(i,s,2),i.isProxied=!0);let c=L("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new i(t)}catch(a){C(a)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),c(),ae(t.$lazyInstance$)}else i=e.constructor,customElements.whenDefined(s.$tagName$).then(()=>t.$flags$|=128);if(n.style&&i.style){let c=i.style;n.mode&&typeof c!="string"&&(c=c[t.$modeName$=Tt(e)],n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));let a=Pe(s,t.$modeName$);if(!X.has(a)){let d=L("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(c=yield import("./chunk-J5VZJBUV.js").then($=>$.scopeCss(c,a,!1))),Nt(a,c,!!(s.$flags$&1)),d()}}}let l=t.$ancestorComponent$,r=()=>J(t,!0);n.asyncLoading&&l&&l["s-rc"]?l["s-rc"].push(r):r()}),ae=e=>{n.lazyLoad&&n.connectedCallback&&x(e,"connectedCallback")},Ft=e=>{if(!(p.$flags$&1)){let t=b(e),s=t.$cmpMeta$,o=L("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&de(e,t,s.$listeners$,!0),t.$flags$&1)de(e,t,s.$listeners$,!1),t?.$lazyInstance$?ae(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ae(t.$lazyInstance$));else{t.$flags$|=1;let i;if(n.hydrateClientSide&&(i=e.getAttribute(ne),i)){if(n.shadowDom&&w&&s.$flags$&1){let l=n.mode?re(e.shadowRoot,s,e.getAttribute("s-mode")):re(e.shadowRoot,s);e.classList.remove(l+"-h",l+"-s")}xt(e,s.$tagName$,i,t)}if(n.slotRelocation&&!i&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&Ut(e),n.asyncLoading){let l=e;for(;l=l.parentNode||l.host;)if(n.hydrateClientSide&&l.nodeType===1&&l.hasAttribute("s-id")&&l["s-p"]||l["s-p"]){Qe(t,t.$ancestorComponent$=l);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([l,[r]])=>{if(r&31&&e.hasOwnProperty(l)){let c=e[l];delete e[l],e[l]=c}}),n.initializeNextTick?Z(()=>_e(e,t,s)):_e(e,t,s)}o()}},Ut=e=>{let t=e["s-cr"]=m.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},ee=e=>{n.lazyLoad&&n.disconnectedCallback&&x(e,"disconnectedCallback"),n.cmpDidUnload&&x(e,"componentDidUnload")},Mt=e=>H(void 0,null,function*(){if(!(p.$flags$&1)){let t=b(e);n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0),n.lazyLoad?t?.$lazyInstance$?ee(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ee(t.$lazyInstance$)):ee(e)}}),Wt=(e,t)=>{Ge(e),Je(e),Xt(e),Qt(e),Gt(e),Kt(e),Yt(e),Ze(e),Ve(e,t),qt(e)},Ge=e=>{let t=e.cloneNode;e.cloneNode=function(s){let o=this,i=n.shadowDom?o.shadowRoot&&w:!1,l=t.call(o,i?s:!1);if(n.slot&&!i&&s){let r=0,c,a,d=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si"];for(;r<o.childNodes.length;r++)c=o.childNodes[r]["s-nr"],a=d.every($=>!o.childNodes[r][$]),c&&(n.appendChildSlotFix&&l.__appendChild?l.__appendChild(c.cloneNode(!0)):l.appendChild(c.cloneNode(!0))),a&&l.appendChild(o.childNodes[r].cloneNode(!0))}return l}},Je=e=>{e.__appendChild=e.appendChild,e.appendChild=function(t){let s=t["s-sn"]=et(t),o=O(this.childNodes,s);if(o){let i=he(o,s),l=i[i.length-1],r=l.parentNode.insertBefore(t,l.nextSibling);return G(this),jt(this),r}return this.__appendChild(t)}},qt=e=>{e.__removeChild=e.removeChild,e.removeChild=function(t){if(t&&typeof t["s-sn"]<"u"){let s=O(this.childNodes,t["s-sn"]);if(s){let i=he(s,t["s-sn"]).find(l=>l===t);if(i){i.remove(),G(this);return}}}return this.__removeChild(t)}},Qt=e=>{let t=e.prepend;e.prepend=function(...s){s.forEach(o=>{typeof o=="string"&&(o=this.ownerDocument.createTextNode(o));let i=o["s-sn"]=et(o),l=O(this.childNodes,i);if(l){let r=document.createTextNode("");r["s-nr"]=o,l["s-cr"].parentNode.__appendChild(r),o["s-ol"]=r;let a=he(l,i)[0];return a.parentNode.insertBefore(o,a.nextSibling)}return o.nodeType===1&&o.getAttribute("slot")&&(o.hidden=!0),t.call(this,o)})}},Xt=e=>{e.append=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s)),this.appendChild(s)})}},Kt=e=>{let t=e.insertAdjacentHTML;e.insertAdjacentHTML=function(s,o){if(s!=="afterbegin"&&s!=="beforeend")return t.call(this,s,o);let i=this.ownerDocument.createElement("_"),l;if(i.innerHTML=o,s==="afterbegin")for(;l=i.firstChild;)this.prepend(l);else if(s==="beforeend")for(;l=i.firstChild;)this.append(l)}},Yt=e=>{e.insertAdjacentText=function(t,s){this.insertAdjacentHTML(t,s)}},Gt=e=>{let t=e.insertAdjacentElement;e.insertAdjacentElement=function(s,o){return s!=="afterbegin"&&s!=="beforeend"?t.call(this,s,o):s==="afterbegin"?(this.prepend(o),o):(s==="beforeend"&&this.append(o),o)}},Ze=e=>{let t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),n.experimentalScopedSlotChanges?Object.defineProperty(e,"textContent",{get(){return" "+ce(this.childNodes).map(i=>{var l,r;let c=[],a=i.nextSibling;for(;a&&a["s-sn"]===i["s-sn"];)(a.nodeType===3||a.nodeType===1)&&c.push((r=(l=a.textContent)===null||l===void 0?void 0:l.trim())!==null&&r!==void 0?r:""),a=a.nextSibling;return c.filter(d=>d!=="").join(" ")}).filter(i=>i!=="").join(" ")+" "},set(s){ce(this.childNodes).forEach(i=>{let l=i.nextSibling;for(;l&&l["s-sn"]===i["s-sn"];){let r=l;l=l.nextSibling,r.remove()}if(i["s-sn"]===""){let r=this.ownerDocument.createTextNode(s);r["s-sn"]="",i.parentElement.insertBefore(r,i.nextSibling)}else i.remove()})}}):Object.defineProperty(e,"textContent",{get(){var s;let o=O(this.childNodes,"");return((s=o?.nextSibling)===null||s===void 0?void 0:s.nodeType)===3?o.nextSibling.textContent:o?o.textContent:this.__textContent},set(s){var o;let i=O(this.childNodes,"");if(((o=i?.nextSibling)===null||o===void 0?void 0:o.nodeType)===3)i.nextSibling.textContent=s;else if(i)i.textContent=s;else{this.__textContent=s;let l=this["s-cr"];l&&this.insertBefore(l,this.firstChild)}}})},Ve=(e,t)=>{class s extends Array{item(i){return this[i]}}if(t.$flags$&8){let o=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map(i=>i.nodeType===1)}}),Object.defineProperty(e,"childElementCount",{get(){return e.children.length}}),Object.defineProperty(e,"childNodes",{get(){let i=o.call(this);if(!(p.$flags$&1)&&b(this).$flags$&2){let l=new s;for(let r=0;r<i.length;r++){let c=i[r]["s-nr"];c&&l.push(c)}return l}return s.from(i)}})}},ce=e=>{let t=[];for(let s of Array.from(e))s["s-sr"]&&t.push(s),t.push(...ce(s.childNodes));return t},et=e=>e["s-sn"]||e.nodeType===1&&e.getAttribute("slot")||"",O=(e,t)=>{let s=0,o;for(;s<e.length;s++)if(o=e[s],o["s-sr"]&&o["s-sn"]===t||(o=O(o.childNodes,t),o))return o;return null},he=(e,t)=>{let s=[e];for(;(e=e.nextSibling)&&e["s-sn"]===t;)s.push(e);return s};var ps=(e,t)=>{let s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!w&&s.$flags$&1&&(s.$flags$|=8),n.experimentalSlotFixes?n.scoped&&s.$flags$&2&&Wt(e.prototype,s):(n.slotChildNodesFix&&Ve(e.prototype,s),n.cloneNodeFix&&Ge(e.prototype),n.appendChildSlotFix&&Je(e.prototype),n.scopedSlotTextContentFix&&s.$flags$&2&&Ze(e.prototype));let o=e.prototype.connectedCallback,i=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){es(this,s)},connectedCallback(){Ft(this),n.connectedCallback&&o&&o.call(this)},disconnectedCallback(){Mt(this),n.disconnectedCallback&&i&&i.call(this)},__attachShadow(){w?n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=s.$tagName$,Ye(e,s,3)};var de=(e,t,s,o)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(o?s=s.filter(([i])=>i&32):s=s.filter(([i])=>!(i&32))),s.map(([i,l,r])=>{let c=n.hostListenerTarget?Zt(e,i):e,a=Jt(t,r),d=Vt(i);p.ael(c,l,a,d),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>p.rel(c,l,a,d))}))},Jt=(e,t)=>s=>{try{n.lazyLoad?e.$flags$&256?e.$lazyInstance$[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(o){C(o)}},Zt=(e,t)=>n.hostListenerTargetDocument&&t&4?m:n.hostListenerTargetWindow&&t&8?z:n.hostListenerTargetBody&&t&16?m.body:n.hostListenerTargetParent&&t&32?e.parentElement:e,Vt=e=>ss?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;var tt=new WeakMap,b=e=>tt.get(e);var es=(e,t)=>{let s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(o=>s.$onInstanceResolve$=o)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(o=>s.$onReadyResolve$=o),e["s-p"]=[],e["s-rc"]=[]),de(e,s,t.$listeners$,!1),tt.set(e,s)},Ee=(e,t)=>t in e,C=(e,t)=>(it||console.error)(e,t),st=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],Q=(...e)=>console.error(...st,...e),P=(...e)=>console.warn(...st,...e);var Ie=new Map,ts=(e,t,s)=>{let o=e.$tagName$.replace(/-/g,"_"),i=e.$lazyBundleId$;if(n.isDev&&typeof i!="string"){Q(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}let l=n.hotModuleReplacement?!1:Ie.get(i);if(l)return l[o];return cs(`./${i}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`).then(r=>(n.hotModuleReplacement||Ie.set(i,r),r[o]),C)},X=new Map,nt=[],z=typeof window<"u"?window:{},m=z.document||{head:{}},gs=z.HTMLElement||class{},p={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,o)=>e.addEventListener(t,s,o),rel:(e,t,s,o)=>e.removeEventListener(t,s,o),ce:(e,t)=>new CustomEvent(e,t)},ms=e=>{Object.assign(p,e)},w=n.shadowDomShim&&n.shadowDom?(()=>(m.head.attachShadow+"").indexOf("[native")>-1)():!0,ss=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),ns=e=>Promise.resolve(e),os=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,U=[],A=[],te=[],ot=(e,t)=>s=>{e.push(s),W||(W=!0,t&&p.$flags$&4?Z(K):p.raf(K))},Re=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){C(s)}e.length=0},Oe=(e,t)=>{let s=0,o=0;for(;s<e.length&&(o=performance.now())<t;)try{e[s++](o)}catch(i){C(i)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},K=()=>{if(n.asyncQueue&&V++,Re(U),n.asyncQueue){let e=(p.$flags$&6)===2?performance.now()+14*Math.ceil(V*.1):1/0;Oe(A,e),Oe(te,e),A.length>0&&(te.push(...A),A.length=0),(W=U.length+A.length+te.length>0)?p.raf(K):V=0}else Re(A),(W=U.length>0)&&p.raf(K)},Z=e=>ns().then(e),ys=ot(U,!1),is=ot(A,!0);export{me as a,$s as b,je as c,yt as d,fs as e,us as f,hs as g,jt as h,ps as i,gs as j,ms as k,ys as l,is as m};
